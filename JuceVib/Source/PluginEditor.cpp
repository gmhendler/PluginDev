/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"



//==============================================================================
JuceVibAudioProcessorEditor::JuceVibAudioProcessorEditor (JuceVibAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p),
	freqLabel(String::empty, "Frequency"),
	depthLabel(String::empty, "Depth")
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (400, 200);

	/*
	// sliders
	addAndMakeVisible(freqSlider = new ParameterSlider(*p.freqParam));
	freqSlider->setSliderStyle(Slider::LinearBarVertical);

	addAndMakeVisible(depthSlider = new ParameterSlider(*p.depthParam));
	depthSlider->setSliderStyle(Slider::LinearBarVertical);

	// add some labels for the sliders..
	freqLabel.attachToComponent(freqSlider, false);
	depthLabel.attachToComponent(depthSlider, false);
	*/

	// sliders 
	fSlider.setSliderStyle(Slider::LinearBarVertical);
	fSlider.setRange(0.0, 1000.0);
	fSlider.setTextBoxStyle(Slider::TextBoxBelow, false, 90, 20);
	fSlider.setTextValueSuffix(" Hz");
	fSlider.setValue(20.0);
	addAndMakeVisible(&fSlider);

	dSlider.setSliderStyle(Slider::LinearBarVertical);
	dSlider.setRange(0.0, 1.0);
	dSlider.setTextBoxStyle(Slider::TextBoxBelow, false, 90, 20);
	dSlider.setValue(0.5);
	addAndMakeVisible(&dSlider);

	// button
	addAndMakeVisible(bypassButton);

	bypassButton.addListener(this);
}

JuceVibAudioProcessorEditor::~JuceVibAudioProcessorEditor()
{
}

//==============================================================================
void JuceVibAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);

    g.setColour (Colours::black);
    g.setFont (15.0f);
    g.drawFittedText("Vibrato", 0, 0, getWidth(), 30, Justification::centred, 1);
}

void JuceVibAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
	fSlider.setBounds(40, 30, 20, getHeight() - 60);
	dSlider.setBounds(80, 30, 20, getHeight() - 60);
	bypassButton.setBounds(100, 30, 20, 20);
}


void JuceVibAudioProcessorEditor::buttonClicked(Button* b) {
	processor.bypassed = bypassButton.getToggleState();
}

void JuceVibAudioProcessorEditor::sliderValueChanged(Slider* s) {
	if (s == &fSlider) {
		processor.freqParam->setValueNotifyingHost((float)fSlider.getValue());
	}
	else if (s == &dSlider) {
		processor.depthParam->setValueNotifyingHost((float)dSlider.getValue());
	}
}

/*
class JuceVibAudioProcessorEditor::ParameterSlider : public Slider,
	private Timer
{
public:
	ParameterSlider(AudioProcessorParameter& p)
		: Slider(p.getName(256)), param(p)
	{
		setRange(0.0, 1.0, 0.0);
		startTimerHz(30);
		updateSliderPos();
	}

	void valueChanged() override
	{
		param.setValueNotifyingHost((float)Slider::getValue());
	}

	void timerCallback() override { updateSliderPos(); }

	void startedDragging() override { param.beginChangeGesture(); }
	void stoppedDragging() override { param.endChangeGesture(); }

	double getValueFromText(const String& text) override { return param.getValueForText(text); }
	String getTextFromValue(double value) override { return param.getText((float)value, 1024); }

	void updateSliderPos()
	{
		const float newValue = param.getValue();

		if (newValue != (float)Slider::getValue() && !isMouseButtonDown())
			Slider::setValue(newValue);
	}

	AudioProcessorParameter& param;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ParameterSlider)
};
*/