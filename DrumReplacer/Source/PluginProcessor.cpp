/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "Vector.h"

//==============================================================================
DrumReplacerAudioProcessor::DrumReplacerAudioProcessor()
{
	initialiseSynth();

	CPPM::createInstance(PPMDisplay);
	CPPM::createInstance(PPMTrigger);
	pcurPPM = new float[2];
	pcurMaxPPM = new float[2];

	COnsetTrigger::createInstance(OnsetTrigger);

	hpFreq = 10;
	lpFreq = 22000;

	dspLpf = new Dsp::SmoothedFilterDesign<Dsp::RBJ::Design::LowPass, 2>(1024);
	dspHpf = new Dsp::SmoothedFilterDesign<Dsp::RBJ::Design::HighPass, 2>(1024);
}

DrumReplacerAudioProcessor::~DrumReplacerAudioProcessor()
{
	CPPM::destroyInstance(PPMDisplay);
	CPPM::destroyInstance(PPMTrigger);

	COnsetTrigger::destroyInstance(OnsetTrigger);

	delete[] pcurMaxPPM;
	pcurMaxPPM = 0;
	delete[] pcurPPM;
	pcurPPM = 0;

}

void DrumReplacerAudioProcessor::initialiseSynth()
{
	const int numVoices = 3;

	// Add some voices...
	for (int i = numVoices; --i >= 0;)
		synth.addVoice(new SamplerVoice());

	// ..and give the synth a sound to play
	//synth.addSound(new SamplerSound());
}

//==============================================================================
const String DrumReplacerAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool DrumReplacerAudioProcessor::acceptsMidi() const
{
#if JucePlugin_WantsMidiInput
return true;
#else
return false;
#endif
}

bool DrumReplacerAudioProcessor::producesMidi() const
{
#if JucePlugin_ProducesMidiOutput
	return true;
#else
	return false;
#endif
}

double DrumReplacerAudioProcessor::getTailLengthSeconds() const
{
	return 0.0;
}

int DrumReplacerAudioProcessor::getNumPrograms()
{
	return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
				// so this should be at least 1, even if you're not really implementing programs.
}

int DrumReplacerAudioProcessor::getCurrentProgram()
{
	return 0;
}

void DrumReplacerAudioProcessor::setCurrentProgram(int index)
{
}

const String DrumReplacerAudioProcessor::getProgramName(int index)
{
	return String();
}

void DrumReplacerAudioProcessor::changeProgramName(int index, const String& newName)
{
}

//==============================================================================
void DrumReplacerAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
{
	// Use this method as the place to do any pre-playback
	// initialisation that you need..
	synth.setCurrentPlaybackSampleRate(sampleRate);

	iSampleRate = sampleRate;

	PPMDisplay->initInstance(sampleRate, 2, .0001, 1.0);
	PPMTrigger->initInstance(sampleRate, 2, .0001, .0001);
	CVectorFloat::setZero(pcurPPM, 2);
	CVectorFloat::setZero(pcurMaxPPM, 2);

	OnsetTrigger->initInstance(sampleRate, 2, 1, .1);

	scratchBuffer.setSize(getNumInputChannels(), samplesPerBlock);
	scratchBuffer2.setSize(getNumInputChannels(), samplesPerBlock);

	lpfParams[0] = sampleRate;
	lpfParams[1] = lpFreq;
	lpfParams[2] = 1;

	hpfParams[0] = sampleRate;
	hpfParams[1] = hpFreq;
	hpfParams[2] = 1;
}

void DrumReplacerAudioProcessor::releaseResources()
{
	// When playback stops, you can use this as an opportunity to free up any
	// spare memory, etc.
}

void DrumReplacerAudioProcessor::processBlock(AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
	const int totalNumInputChannels = getTotalNumInputChannels();
	const int totalNumOutputChannels = getTotalNumOutputChannels();

	float** ppfWriteBuffer = buffer.getArrayOfWritePointers();

	//Filter Input
	AudioSampleBuffer filterBuffer(scratchBuffer2.getArrayOfWritePointers(), buffer.getNumChannels(), buffer.getNumSamples());
	for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
		filterBuffer.copyFrom(ch, 0, buffer, ch, 0, buffer.getNumSamples());

	float** ppfFilterBuffer = filterBuffer.getArrayOfWritePointers();
	


	dspLpf->setParams(lpfParams);
	dspLpf->process(buffer.getNumSamples(), ppfFilterBuffer);
	dspHpf->setParams(hpfParams);
	dspHpf->process(buffer.getNumSamples(), ppfFilterBuffer);

	
	AudioSampleBuffer tmpBuffer(scratchBuffer.getArrayOfWritePointers(), buffer.getNumChannels(), filterBuffer.getNumSamples());
	for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
		tmpBuffer.copyFrom(ch, 0, buffer, ch, 0, buffer.getNumSamples());


	float** ppfTempBuffer = tmpBuffer.getArrayOfWritePointers();

	const int numSamples = buffer.getNumSamples();

	//PPM
	//NEED TO INPUT FILTER BUFFER
	PPMDisplay->process(ppfFilterBuffer, NULL, buffer.getNumSamples());
	PPMTrigger->process(ppfFilterBuffer, ppfTempBuffer, buffer.getNumSamples());
	pcurPPM[0] = PPMDisplay->getPPMChannelValue(0);
	pcurPPM[1] = PPMDisplay->getPPMChannelValue(1);

	for (int i = 0; i < 2; i++)
	{
		if (pcurPPM[i] > pcurMaxPPM[i]) {
			pcurMaxPPM[i] = pcurPPM[i];
		}
	}

	//Onset Detector
	OnsetTrigger->process(ppfTempBuffer, ppfTempBuffer, tmpBuffer.getNumSamples());


	//Trigger Clip
	for (int i = 0; i < tmpBuffer.getNumSamples(); i++)
	{
		for (int c = 0; c < totalNumInputChannels; c++)
		{
			if (ppfTempBuffer[c][i] == 1){
				synth.noteOn(0, 1, clip1Gain);
				triggered = true;
			}
		}
	}

	checked = true;

	//play sample
	synth.renderNextBlock(buffer, midiMessages, 0, numSamples);

    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // This is here to avoid people getting screaming feedback
    // when they first compile a plugin, but obviously you don't need to keep
    // this code if your algorithm always overwrites all the output channels.
    for (int i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
	float samp = 0.0;
    for (int channel = 0; channel < totalNumInputChannels; ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);

        // ..do something to the data...
		for (int i = 0; i < numSamples; i++) {
			if (monitorFilters) {
				samp = filterBuffer.getSample(channel, i);
			}
			else {
				samp = buffer.getSample(channel, i);
			}
			buffer.setSample(channel, i, samp * thruGain);
		}
    }
}

//==============================================================================
bool DrumReplacerAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* DrumReplacerAudioProcessor::createEditor()
{
    return new DrumReplacerAudioProcessorEditor (*this);
}

//==============================================================================
void DrumReplacerAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void DrumReplacerAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

void DrumReplacerAudioProcessor::setSamplerSound(int clipNum, AudioFormatReader *source)
{
	if (clipNum == 1) {
		int note = 1;
		BigInteger notes;
		notes.setRange(note, 1, true);
		clip1 = new SamplerSound("Clip1", *source, notes, note, 0.0, 0.1, 30.0);
		synth.removeSound(1);
		synth.addSound(clip1);
	}
}

void DrumReplacerAudioProcessor::playClip(int clipNum) {
	synth.noteOn(0, clipNum, clip1Gain);
}

void DrumReplacerAudioProcessor::setThruGain(float gain) {
	thruGain = gain;
}

void DrumReplacerAudioProcessor::setClipGain(float gain, int clipNum) {
	if (clipNum == 1) {
		clip1Gain = gain;
	}
}

AudioSampleBuffer *  DrumReplacerAudioProcessor::getClipBuffer(int clipNum) {
	if (clipNum == 1) {
		return clip1->getAudioData();
	}
	return nullptr;
}

void DrumReplacerAudioProcessor::setThresh(float t) {
	thresh = pow(10,(t/20));
	OnsetTrigger->setThreshold(thresh);
}

void DrumReplacerAudioProcessor::setRecovery(float r) {
	recovery = r;
	OnsetTrigger->setDelayTime(recovery);
}

float DrumReplacerAudioProcessor::getCurMaxPPM(int c) {
	return pcurMaxPPM[c];
}

void DrumReplacerAudioProcessor::resetCurMaxPPM() {
	for (int i = 0; i < 2; i++)
	{
		pcurMaxPPM[i] = 0;
		checked = false;
	}
}

bool DrumReplacerAudioProcessor::isChecked() {
	return checked;
}

bool DrumReplacerAudioProcessor::isTriggered() {
	return triggered;
}

void DrumReplacerAudioProcessor::setTriggered(bool trig) {
	triggered = trig;
}

void DrumReplacerAudioProcessor::setFilterMon(bool state) {
	monitorFilters = state;
}

void DrumReplacerAudioProcessor::setHPF(float freq) {
	hpfParams[1] = freq;
}

void DrumReplacerAudioProcessor::setLPF(float freq) {
	lpfParams[1] = freq;
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new DrumReplacerAudioProcessor();
}
