/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
DrumReplacerAudioProcessorEditor::DrumReplacerAudioProcessorEditor(DrumReplacerAudioProcessor& p)
	: AudioProcessorEditor(&p), processor(p)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.

	setSize(800, 800);

	startTimer(10);

	waveform1.clearWaveformBuffer();
	addAndMakeVisible(waveform1);

	formatManager.registerBasicFormats();

	setLookAndFeel(&lookAndFeel);

	addAndMakeVisible(&openButton);
	openButton.setButtonText("Open...");
	openButton.addListener(this);

	addAndMakeVisible(&playButton);
	playButton.setButtonText("Play");
	playButton.addListener(this);
	playButton.setColour(TextButton::buttonColourId, Colours::green);
	playButton.setEnabled(false);

	gain1.setRange(0.0, 1.0);
	gain1.setValue(0.75);
	gain1.addListener(this);
	addAndMakeVisible(&gain1);

	gainThru.setRange(0.0, 1.0);
	gainThru.setValue(0.75);
	gainThru.addListener(this);
	addAndMakeVisible(&gainThru);

	threshSlider.setSliderStyle(Slider::LinearBarVertical);
	threshSlider.setRange(-12.0, 0);
	threshSlider.setValue(-6.0);
	threshSlider.addListener(this);
	addAndMakeVisible(&threshSlider);

	recoverySlider.setSliderStyle(Slider::Rotary);
	recoverySlider.setRange(.001, .1);
	recoverySlider.setValue(.05);
	recoverySlider.addListener(this);
	addAndMakeVisible(&recoverySlider);

	HPF.setSliderStyle(Slider::Rotary);
	HPF.setRange(10, 22000);
	HPF.setValue(10);
	HPF.addListener(this);
	addAndMakeVisible(&HPF);

	LPF.setSliderStyle(Slider::Rotary);
	LPF.setRange(10, 22000);
	LPF.setValue(22000);
	LPF.addListener(this);
	addAndMakeVisible(&LPF);

	zoomSlider.setRange(0.0, 1.0);
	zoomSlider.setValue(1.0);
	zoomSlider.addListener(this);
	addAndMakeVisible(&zoomSlider);

	// button
	filterButton.setToggleState(false, true);
	addAndMakeVisible(filterButton);
	filterButton.addListener(this);

	//meters
	meterL.setName("ppmL");
	addAndMakeVisible(meterL);

	meterR.setName("ppmR");
	addAndMakeVisible(meterR);


}

DrumReplacerAudioProcessorEditor::~DrumReplacerAudioProcessorEditor()
{

}

//==============================================================================
void DrumReplacerAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);

}

void DrumReplacerAudioProcessorEditor::resized()
{
	openButton.setBounds(10, 10, 50, 20);
	playButton.setBounds(10, 40, 50, 20);

	gain1.setBounds(80, 10, 200, 50);
	gainThru.setBounds(10, 300, 200, 50);

	meterL.setBounds(320, 100, 20,180);
	meterR.setBounds(340, 100, 20, 180);
	threshSlider.setBounds(300, 100, 20, 180);

	recoverySlider.setBounds(10, 80, 50, 50);

	HPF.setBounds(10, 150, 50, 50);
	LPF.setBounds(10, 210, 50, 50);

	waveform1.setBounds(350, 350, 400, 300);

	zoomSlider.setBounds(350, 700, 400, 50);

	filterButton.setBounds(100, 500, 30, 30);
}

void DrumReplacerAudioProcessorEditor::buttonClicked(Button * button)
{
	if (button == &openButton)      openButtonClicked();
	if (button == &playButton)      playButtonClicked();
	if (button == &filterButton) {
		processor.setFilterMon(button->getToggleState());
	}
}

void DrumReplacerAudioProcessorEditor::sliderValueChanged(Slider* s) {
	if (s == &gainThru) {
		processor.setThruGain((float)gainThru.getValue());
	}
	if (s == &gain1) {
		processor.setClipGain((float)gain1.getValue(), 1);
	}
	if (s == &threshSlider) {
		processor.setThresh((float)threshSlider.getValue());
	}
	if (s == &recoverySlider) {
		processor.setRecovery((float)recoverySlider.getValue());
	}
	if (s == &HPF) {
		processor.setHPF((float)HPF.getValue());
	}
	if (s == &LPF) {
		processor.setLPF((float)LPF.getValue());
	}
	if (s == &zoomSlider) {
		zoom = zoomSlider.getValue();
		waveform1.setZoom(zoom);
	}
}


//OPEN FILE
void DrumReplacerAudioProcessorEditor::openButtonClicked()
{
	FileChooser chooser("Select a Wave file...",
		File::nonexistent,
		"*.wav");

	if (chooser.browseForFileToOpen())
	{
		File file(chooser.getResult());
		AudioFormatReader* reader = formatManager.createReaderFor(file);

		if (reader != nullptr)
		{
			playButton.setEnabled(true);
			processor.setSamplerSound(1, reader);
			AudioSampleBuffer * clipBuff = processor.getClipBuffer(1);
			waveform1.clearWaveformBuffer();

			waveLen = zoom * clipBuff->getNumSamples();

			waveform1.updateBuffer(*clipBuff, waveLen);
		}
	}
}

void DrumReplacerAudioProcessorEditor::playButtonClicked()
{
	processor.playClip(1);
}

void DrumReplacerAudioProcessorEditor::timerCallback() {
	meterL.setValue(processor.getCurMaxPPM(0));
	meterR.setValue(processor.getCurMaxPPM(1));
	if (processor.isChecked()) {
		processor.resetCurMaxPPM();
	}

}

