/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
DrumReplacerAudioProcessorEditor::DrumReplacerAudioProcessorEditor(DrumReplacerAudioProcessor& p)
	: AudioProcessorEditor(&p), processor(p)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.

	setSize(800, 800);

	processor.addChangeListener(this);

	startTimer(10);

	waveform1.clearWaveformBuffer();
	addAndMakeVisible(waveform1);

	triggerWave.clearWaveformBuffer();
	addAndMakeVisible(triggerWave);

	formatManager.registerBasicFormats();

	setLookAndFeel(&lookAndFeel);

	addAndMakeVisible(&openButton);
	openButton.setButtonText("Open...");
	openButton.addListener(this);

	addAndMakeVisible(&playButton);
	playButton.setButtonText("Play");
	playButton.addListener(this);
	playButton.setColour(TextButton::buttonColourId, Colours::green);
	playButton.setEnabled(false);

	gain1.setRange(0.0, 1.0);
	gain1.setValue(0.75);
	gain1.addListener(this);
	addAndMakeVisible(&gain1);

	gainThru.setRange(0.0, 1.0);
	gainThru.setValue(0.75);
	gainThru.addListener(this);
	addAndMakeVisible(&gainThru);

	threshSlider.setSliderStyle(Slider::LinearBarVertical);
	threshSlider.setRange(-12.0, 0);
	threshSlider.setValue(-6.0);
	threshSlider.addListener(this);
	addAndMakeVisible(&threshSlider);

	recoverySlider.setSliderStyle(Slider::Rotary);
	recoverySlider.setRange(.001, .1);
	recoverySlider.setValue(.05);
	recoverySlider.addListener(this);
	addAndMakeVisible(&recoverySlider);

	HPF.setSliderStyle(Slider::Rotary);
	HPF.setRange(10, 22000);
	HPF.setValue(10);
	HPF.addListener(this);
	addAndMakeVisible(&HPF);

	LPF.setSliderStyle(Slider::Rotary);
	LPF.setRange(10, 22000);
	LPF.setValue(22000);
	LPF.addListener(this);
	addAndMakeVisible(&LPF);

	zoomSlider.setRange(0.0, 1.0);
	zoomSlider.setValue(1.0);
	zoomSlider.addListener(this);
	addAndMakeVisible(&zoomSlider);

	offsetSlider.setRange(-50, 50);
	offsetSlider.setValue(0);
	offsetSlider.setDoubleClickReturnValue(true, 0);

	offsetSlider.addListener(this);
	addAndMakeVisible(&offsetSlider);

	// button
	filterButton.setToggleState(false, true);
	addAndMakeVisible(filterButton);
	filterButton.addListener(this);

	phaseButton.setToggleState(false, true);
	addAndMakeVisible(phaseButton);
	phaseButton.addListener(this);

	//meters
	meterL.setName("ppmL");
	addAndMakeVisible(meterL);

	meterR.setName("ppmR");
	addAndMakeVisible(meterR);


}

DrumReplacerAudioProcessorEditor::~DrumReplacerAudioProcessorEditor()
{

}

//==============================================================================
void DrumReplacerAudioProcessorEditor::paint (Graphics& g)
{
    g.fillAll (Colours::white);

}

void DrumReplacerAudioProcessorEditor::resized()
{
	openButton.setBounds(10, 10, 50, 20);
	playButton.setBounds(10, 40, 50, 20);

	gain1.setBounds(80, 10, 200, 50);
	gainThru.setBounds(10, 300, 200, 50);

	meterL.setBounds(320, 100, 20,180);
	meterR.setBounds(340, 100, 20, 180);
	threshSlider.setBounds(300, 100, 20, 180);

	recoverySlider.setBounds(10, 80, 50, 50);

	HPF.setBounds(10, 150, 50, 50);
	LPF.setBounds(10, 210, 50, 50);

	waveform1.setBounds(10, 350, 300, 300);

	triggerWave.setBounds(400, 350, 300, 300);

	zoomSlider.setBounds(10, 700, 300, 50);

	filterButton.setBounds(700, 10, 30, 30);
	phaseButton.setBounds(740, 10, 30, 30);

	offsetSlider.setBounds(400, 100, 300, 50);
}

void DrumReplacerAudioProcessorEditor::buttonClicked(Button * button)
{
	if (button == &openButton)      openButtonClicked();
	if (button == &playButton)      playButtonClicked();
	if (button == &filterButton) {
		processor.setFilterMon(button->getToggleState());
	}
	if (button == &phaseButton) {
		bool ph = button->getToggleState();
		processor.setPhase(ph);

		AudioSampleBuffer * clipBuff = processor.getClipBuffer(1);

		clipBuff->applyGain(-1.0);
				
		waveform1.clearWaveformBuffer();

		waveLen = clipBuff->getNumSamples();

		waveform1.updateBuffer(*clipBuff, waveLen);

		processor.setTriggerBufferLength(waveLen);
	}
}

void DrumReplacerAudioProcessorEditor::sliderValueChanged(Slider* s) {
	if (s == &gainThru) {
		processor.setThruGain((float)gainThru.getValue());
	}
	if (s == &gain1) {
		processor.setClipGain((float)gain1.getValue(), 1);
	}
	if (s == &threshSlider) {
		processor.setThresh((float)threshSlider.getValue());
	}
	if (s == &recoverySlider) {
		processor.setRecovery((float)recoverySlider.getValue());
	}
	if (s == &HPF) {
		processor.setHPF((float)HPF.getValue());
	}
	if (s == &LPF) {
		processor.setLPF((float)LPF.getValue());
	}
	if (s == &zoomSlider) {
		zoom = zoomSlider.getValue();
		waveform1.setZoom(zoom);
		triggerWave.setZoom(zoom);
	}
	if (s == &offsetSlider) {
		processor.setOffset((int)(offsetSlider.getValue()));

		int offset = (int)(offsetSlider.getValue() * processor.getSampleRate() / 1000);

		AudioSampleBuffer * clipBuff = processor.getClipBuffer(1);
		float samp = 0.0;
		clipBuff->applyGain(0);
		for (int channel = 0; channel < clipBuff->getNumChannels(); ++channel)
		{
			for (int i = 0; i < clipBuff->getNumSamples(); i++) {

				samp = clipBufferOrig.getSample(channel, i);
				if (((i + offset) > 0) && ((i + offset) < clipBuff->getNumSamples())) {
					clipBuff->setSample(channel, i + offset, samp);
				}
			}
		}

		waveform1.clearWaveformBuffer();

		waveLen = clipBuff->getNumSamples();

		waveform1.updateBuffer(*clipBuff, waveLen);

		processor.setTriggerBufferLength(waveLen);
	}
}


//OPEN FILE
void DrumReplacerAudioProcessorEditor::openButtonClicked()
{
	FileChooser chooser("Select a Wave file...",
		File::nonexistent,
		"*.wav");

	if (chooser.browseForFileToOpen())
	{
		File file(chooser.getResult());
		AudioFormatReader* reader = formatManager.createReaderFor(file);

		if (reader != nullptr)
		{
			playButton.setEnabled(true);
			processor.setSamplerSound(reader);
			AudioSampleBuffer * clipBuff = processor.getClipBuffer(1);
			clipBufferOrig.makeCopyOf(*clipBuff);

			waveform1.clearWaveformBuffer();

			waveLen = clipBuff->getNumSamples();

			waveform1.updateBuffer(*clipBuff, waveLen);

			processor.setTriggerBufferLength(waveLen);

			offsetSlider.setValue(0);
			phaseButton.setToggleState(false, true);
		}
	}
}

void DrumReplacerAudioProcessorEditor::playButtonClicked()
{
	processor.playClip(1);
}

void DrumReplacerAudioProcessorEditor::timerCallback() {
	meterL.setValue(processor.getCurMaxPPM(0));
	meterR.setValue(processor.getCurMaxPPM(1));
	if (processor.isChecked()) {
		processor.resetCurMaxPPM();
	}
	
}

void DrumReplacerAudioProcessorEditor::changeListenerCallback(ChangeBroadcaster *source) {
	AudioSampleBuffer * waveBuff = processor.getTriggerBuffer();
	triggerWave.clearWaveformBuffer();

	triggerWave.updateBuffer(*waveBuff, waveLen);
}

